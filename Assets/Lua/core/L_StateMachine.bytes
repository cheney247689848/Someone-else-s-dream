require "L_State"
module(...,package.seeall)
m_pOwner = nil
m_pCurrentState = nil
m_pPreviousState = nil
m_pGlobalState = nil

function L_StateMachine:Update(nTimer)

    if self.m_pCurrentState ~= nil then
    
        self.m_pCurrentState:Execute(nTimer)
    end

    if self.m_pGlobalState ~= nil then
        self.m_pGlobalState:Execute(nTimer)
    end
end

function L_StateMachine:FixedUpdate(nTimer)

    if self.m_pCurrentState ~= nil then

        self.m_pCurrentState:FixedExcute(nTimer)
    end

    if self.m_pGlobalState ~= nil then
    
        self.m_pGlobalState:FixedExcute(nTimer)
    end
end

function L_StateMachine:ChangeState(newState)

	self.m_pPreviousState = self.m_pCurrentState
	self.m_pCurrentState = newState
	self.m_pCurrentState.m_pOwner = self
	self.m_pPreviousState:Exit()
	self.m_pCurrentState:Enter()
end

function L_StateMachine:SetCurrentState(newState)

    self.m_pCurrentState = newState;
    self.m_pCurrentState.m_pOwner = self
    self.m_pCurrentState:Enter()
end

function L_StateMachine:SetGlobalState(newState)

    self.m_pGlobalState = newState;
    self.m_pGlobalState.m_pOwner = self;
    self.m_pGlobalState:Enter ()
end

function L_StateMachine:GetCurrentState()

    return self.m_pCurrentState
end

function L_StateMachine:GetPreviousState()

    return self.m_pPreviousState
end

function L_StateMachine:GetGlobalState()

    return self.m_pGlobalState
end

function L_StateMachine:New()

    o = {}
    setmetatable(o , self)
    self.__index = self
    return o;
end

